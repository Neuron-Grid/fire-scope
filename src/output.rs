use crate::common::{IpFamily, OutputFormat};
use chrono::{Datelike, Local, Timelike};
use ipnet::IpNet;
use std::{
    collections::BTreeSet,
    error::Error,
    fs::{self, OpenOptions},
    io::Write,
    path::Path,
};

/// 1. 国コード用: IPv4/IPv6リストをファイルに書き出す
pub fn write_ip_lists_to_files(
    country_code: &str,
    ipv4_list: &BTreeSet<IpNet>,
    ipv6_list: &BTreeSet<IpNet>,
    mode: &str,
    format_enum: OutputFormat,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    match format_enum {
        OutputFormat::Txt => {
            // 従来のテキストファイル出力
            let ipv4_file = format!("IPv4_{}.txt", country_code);
            let ipv6_file = format!("IPv6_{}.txt", country_code);

            write_single_ip_list_txt(&ipv4_file, ipv4_list, mode)?;
            write_single_ip_list_txt(&ipv6_file, ipv6_list, mode)?;
        }
        OutputFormat::Nft => {
            // nftables用ファイル出力
            let ipv4_file = format!("IPv4_{}.nft", country_code);
            let ipv6_file = format!("IPv6_{}.nft", country_code);

            write_single_ip_list_nft(&ipv4_file, ipv4_list, mode, country_code, IpFamily::V4)?;
            write_single_ip_list_nft(&ipv6_file, ipv6_list, mode, country_code, IpFamily::V6)?;
        }
    }
    Ok(())
}

/// テキストファイルへの書き込み
fn write_single_ip_list_txt<P: AsRef<Path>>(
    path: P,
    nets: &BTreeSet<IpNet>,
    mode: &str,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let now = Local::now();
    let formatted_header = format!(
        "# {}/{}/{} {}:{}\n",
        now.year(),
        now.month(),
        now.day(),
        now.hour(),
        now.minute()
    );

    let lines: Vec<String> = nets.iter().map(|net| net.to_string()).collect();
    let content = format!("{}{}\n", formatted_header, lines.join("\n"));

    match mode {
        "append" => {
            let mut file = OpenOptions::new().create(true).append(true).open(&path)?;
            file.write_all(content.as_bytes())?;
            println!("[output] Appended IP list to: {}", path.as_ref().display());
        }
        _ => {
            fs::write(&path, &content)?;
            println!(
                "[output] Wrote (overwrite) IP list to: {}",
                path.as_ref().display()
            );
        }
    }

    Ok(())
}

/// nftables用ファイルへの書き込み
fn write_single_ip_list_nft<P: AsRef<Path>>(
    path: P,
    nets: &BTreeSet<IpNet>,
    mode: &str,
    label: &str,
    family: IpFamily,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let now = Local::now();
    let now_str = format!(
        "{}-{:02}-{:02} {:02}:{:02}",
        now.year(),
        now.month(),
        now.day(),
        now.hour(),
        now.minute()
    );

    // familyに応じたコマンド
    let family_cmd = match family {
        IpFamily::V4 => "ip",
        IpFamily::V6 => "ip6",
    };
    // テーブル名
    let table_name = format!("{}_{}", family_cmd, label); // 例: ip_JP, ip6_JP など

    // サンプルルールを生成
    let mut rules = String::new();
    rules.push_str("# Generated by fire_scope\n");
    rules.push_str(&format!("# Date: {}\n", now_str));
    rules.push_str(&format!("# Label: {}\n\n", label));
    rules.push_str(&format!("flush table {} {}\n", family_cmd, table_name));
    rules.push_str(&format!("table {} {} {{\n", family_cmd, table_name));
    rules.push_str("    chain input {\n");
    rules.push_str("        type filter hook input priority 0; policy accept;\n\n");

    for net in nets {
        // 例: ip saddr x.x.x.x/yy counter accept
        let rule_str = format!("        {} saddr {} counter accept\n", family_cmd, net);
        rules.push_str(&rule_str);
    }

    rules.push_str("    }\n}\n");

    match mode {
        "append" => {
            let mut file = OpenOptions::new().create(true).append(true).open(&path)?;
            file.write_all(rules.as_bytes())?;
            println!(
                "[output] Appended nft rules to: {}",
                path.as_ref().display()
            );
        }
        _ => {
            fs::write(&path, &rules)?;
            println!(
                "[output] Wrote (overwrite) nft rules to: {}",
                path.as_ref().display()
            );
        }
    }

    Ok(())
}

/// 2. AS番号用: IPv4/IPv6リストをファイルに書き出す
pub fn write_as_ip_list_to_file(
    as_number: &str,
    family: IpFamily,
    ipnets: &BTreeSet<IpNet>,
    mode: &str,
    format_enum: OutputFormat,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    match format_enum {
        OutputFormat::Txt => {
            // 従来のテキストファイル出力
            let file_name = format!("AS_{}_{}.txt", as_number, family.as_str());
            write_as_ip_list_txt(&file_name, ipnets, mode)?;
        }
        OutputFormat::Nft => {
            // nftables用出力
            let file_name = format!("AS_{}_{}.nft", as_number, family.as_str());
            write_as_ip_list_nft(&file_name, ipnets, mode, as_number, family)?;
        }
    }
    Ok(())
}

/// テキスト出力
/// AS番号用
fn write_as_ip_list_txt(
    file_name: &str,
    ipnets: &BTreeSet<IpNet>,
    mode: &str,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let now = Local::now().format("%Y-%m-%d %H:%M").to_string();
    let header = format!("# Execution Date and Time: {}\n", now);
    let body = ipnets
        .iter()
        .map(IpNet::to_string)
        .collect::<Vec<_>>()
        .join("\n");
    let content = format!("{}{}\n", header, body);

    match mode {
        "append" => {
            let mut file = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&file_name)?;
            file.write_all(content.as_bytes())?;
            println!("[output] Appended IP list to: {}", file_name);
        }
        _ => {
            fs::write(&file_name, content)?;
            println!("[output] Wrote (overwrite) IP list to: {}", file_name);
        }
    }

    Ok(())
}

/// nftables出力
/// AS番号用
fn write_as_ip_list_nft(
    file_name: &str,
    ipnets: &BTreeSet<IpNet>,
    mode: &str,
    as_number: &str,
    family: IpFamily,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let now_str = chrono::Local::now().format("%Y-%m-%d %H:%M").to_string();
    let family_cmd = match family {
        IpFamily::V4 => "ip",
        IpFamily::V6 => "ip6",
    };
    let table_name = format!("{}_{}", family_cmd, as_number);

    let mut rules = String::new();
    rules.push_str("# Generated by fire_scope\n");
    rules.push_str(&format!("# Date: {}\n", now_str));
    rules.push_str(&format!("# AS Number: {}\n\n", as_number));
    rules.push_str(&format!("flush table {} {}\n", family_cmd, table_name));
    rules.push_str(&format!("table {} {} {{\n", family_cmd, table_name));
    rules.push_str("    chain input {\n");
    rules.push_str("        type filter hook input priority 0; policy accept;\n\n");

    for net in ipnets {
        let rule_str = format!("        {} saddr {} counter accept\n", family_cmd, net);
        rules.push_str(&rule_str);
    }
    rules.push_str("    }\n}\n");

    match mode {
        "append" => {
            let mut file = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&file_name)?;
            file.write_all(rules.as_bytes())?;
            println!("[output] Appended nft rules to: {}", file_name);
        }
        _ => {
            fs::write(&file_name, rules)?;
            println!("[output] Wrote (overwrite) nft rules to: {}", file_name);
        }
    }

    Ok(())
}

/// 国コード & AS番号の重複CIDRリストを書き出す
/// Overlap用
pub fn write_overlap_to_file(
    country_code: &str,
    as_number: &str,
    overlaps: &BTreeSet<IpNet>,
    mode: &str,
    format_enum: OutputFormat,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    // IPv4 / IPv6 を仕分け
    let overlaps_v4: BTreeSet<IpNet> = overlaps
        .iter()
        .cloned()
        .filter(|net| matches!(net, IpNet::V4(_)))
        .collect();

    let overlaps_v6: BTreeSet<IpNet> = overlaps
        .iter()
        .cloned()
        .filter(|net| matches!(net, IpNet::V6(_)))
        .collect();

    // 重複がなければファイル出力しない
    if overlaps_v4.is_empty() && overlaps_v6.is_empty() {
        println!(
            "[overlap] No overlap found for country={} and AS={}",
            country_code, as_number
        );
        return Ok(());
    }

    match format_enum {
        OutputFormat::Txt => {
            // 従来のテキスト出力
            write_overlap_txt(country_code, as_number, &overlaps_v4, &overlaps_v6, mode)?;
        }
        OutputFormat::Nft => {
            // nftables出力
            write_overlap_nft(country_code, as_number, &overlaps_v4, &overlaps_v6, mode)?;
        }
    }

    Ok(())
}

/// txt出力
/// Overlaps
fn write_overlap_txt(
    country_code: &str,
    as_number: &str,
    overlaps_v4: &BTreeSet<IpNet>,
    overlaps_v6: &BTreeSet<IpNet>,
    mode: &str,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let now_str = chrono::Local::now().format("%Y-%m-%d %H:%M").to_string();

    // IPv4
    if !overlaps_v4.is_empty() {
        let filename_v4 = format!("overlap_{}_{}_IPv4.txt", country_code, as_number);
        let header_v4 = format!(
            "# Overlap (IPv4) between Country={} and AS={} at {}\n",
            country_code, as_number, now_str
        );
        let body_v4 = overlaps_v4
            .iter()
            .map(|net| net.to_string())
            .collect::<Vec<_>>()
            .join("\n");
        let content_v4 = format!("{}\n{}\n", header_v4, body_v4);

        match mode {
            "append" => {
                let mut file = OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(&filename_v4)?;
                file.write_all(content_v4.as_bytes())?;
                println!("[overlap] Appended IPv4 overlaps to: {}", filename_v4);
            }
            _ => {
                fs::write(&filename_v4, &content_v4)?;
                println!("[overlap] Wrote IPv4 overlaps to: {}", filename_v4);
            }
        }
    }

    // IPv6
    if !overlaps_v6.is_empty() {
        let filename_v6 = format!("overlap_{}_{}_IPv6.txt", country_code, as_number);
        let header_v6 = format!(
            "# Overlap (IPv6) between Country={} and AS={} at {}\n",
            country_code, as_number, now_str
        );
        let body_v6 = overlaps_v6
            .iter()
            .map(|net| net.to_string())
            .collect::<Vec<_>>()
            .join("\n");
        let content_v6 = format!("{}\n{}\n", header_v6, body_v6);

        match mode {
            "append" => {
                let mut file = OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(&filename_v6)?;
                file.write_all(content_v6.as_bytes())?;
                println!("[overlap] Appended IPv6 overlaps to: {}", filename_v6);
            }
            _ => {
                fs::write(&filename_v6, &content_v6)?;
                println!("[overlap] Wrote IPv6 overlaps to: {}", filename_v6);
            }
        }
    }

    Ok(())
}

/// nft出力
/// Overlaps
fn write_overlap_nft(
    country_code: &str,
    as_number: &str,
    overlaps_v4: &BTreeSet<IpNet>,
    overlaps_v6: &BTreeSet<IpNet>,
    mode: &str,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let now_str = chrono::Local::now().format("%Y-%m-%d %H:%M").to_string();

    // IPv4
    if !overlaps_v4.is_empty() {
        let filename_v4 = format!("overlap_{}_{}_IPv4.nft", country_code, as_number);
        let mut rules_v4 = String::new();

        rules_v4.push_str("# Overlap (IPv4) nft rules\n");
        rules_v4.push_str(&format!("# Date: {}\n", now_str));
        rules_v4.push_str(&format!(
            "# Country={} / AS={}\n\n",
            country_code, as_number
        ));

        let family_cmd = "ip";
        let table_name = format!("{}_{}_IPv4", country_code, as_number);
        rules_v4.push_str(&format!("flush table {} {}\n", family_cmd, table_name));
        rules_v4.push_str(&format!("table {} {} {{\n", family_cmd, table_name));
        rules_v4.push_str("    chain input {\n");
        rules_v4.push_str("        type filter hook input priority 0; policy accept;\n\n");

        for net in overlaps_v4 {
            let rule_str = format!("        {} saddr {} counter accept\n", family_cmd, net);
            rules_v4.push_str(&rule_str);
        }
        rules_v4.push_str("    }\n}\n");

        match mode {
            "append" => {
                let mut file = OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(&filename_v4)?;
                file.write_all(rules_v4.as_bytes())?;
                println!("[overlap] Appended IPv4 overlaps nft to: {}", filename_v4);
            }
            _ => {
                fs::write(&filename_v4, rules_v4)?;
                println!("[overlap] Wrote IPv4 overlaps nft to: {}", filename_v4);
            }
        }
    }

    // IPv6
    if !overlaps_v6.is_empty() {
        let filename_v6 = format!("overlap_{}_{}_IPv6.nft", country_code, as_number);
        let mut rules_v6 = String::new();

        rules_v6.push_str("# Overlap (IPv6) nft rules\n");
        rules_v6.push_str(&format!("# Date: {}\n", now_str));
        rules_v6.push_str(&format!(
            "# Country={} / AS={}\n\n",
            country_code, as_number
        ));

        let family_cmd = "ip6";
        let table_name = format!("{}_{}_IPv6", country_code, as_number);
        rules_v6.push_str(&format!("flush table {} {}\n", family_cmd, table_name));
        rules_v6.push_str(&format!("table {} {} {{\n", family_cmd, table_name));
        rules_v6.push_str("    chain input {\n");
        rules_v6.push_str("        type filter hook input priority 0; policy accept;\n\n");

        for net in overlaps_v6 {
            let rule_str = format!("        {} saddr {} counter accept\n", family_cmd, net);
            rules_v6.push_str(&rule_str);
        }
        rules_v6.push_str("    }\n}\n");

        match mode {
            "append" => {
                let mut file = OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(&filename_v6)?;
                file.write_all(rules_v6.as_bytes())?;
                println!("[overlap] Appended IPv6 overlaps nft to: {}", filename_v6);
            }
            _ => {
                fs::write(&filename_v6, rules_v6)?;
                println!("[overlap] Wrote IPv6 overlaps nft to: {}", filename_v6);
            }
        }
    }

    Ok(())
}
